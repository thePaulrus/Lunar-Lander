
# Global Function Pointers

All functions, like variables, exist at a fixed place in memory. The address of the instructions generated by the compiler is available when writing code.

These addresses can be stored in a variable, and called using that function pointer

The first issue to deal is knowing the datatype for a function pointer. The datatype will be different depending on the function prototype.

```c++
// Functions:
void testFunc0() {}
void testFunc1(int a) {}
float testFunc2(float b, char c) {}

// Function Pointers. i.e. Variables that can hold the address of functions.
void (*testFuncPointer)() = testFunc0;
void (*testFuncPointer)(int) = testFunc1;
float (*testFuncPointer)(float, char) = testFunc2;
```

This can be made prettier by defining new types using **typedef**s

```c++
typedef int (*MathOp)(int, int);
```

This defines a new type that can hold the address of any function that matches the argument list and return type. This new type is simply called "MathOp".

```c++
MathOp op = &add; // The '&' is optional.
```

Then, of course, you can call these new variables just like you'd call the function:

```c++
int result = op( 6, 2 );
```

#### Complete example

```c++
typedef int (*MathOp)(int, int);

int add(int v1, int v2) { return v1+v2; }
int subtract(int v1, int v2) { return v1-v2; }

int main()
{
    MathOp op = &add;
    int total = op( 5, 4 );

    op = &subtract;
    total = op( total, 2 );

    return total;
}
```

# Class Method Pointers

Pointers to methods (member functions) work a bit differently.

First we create a new data type, this time using the classâ€™s scope

```c++
typedef void (Game::*OnEventFunction)(Event* pEvent);
```

Notice the class "Game" is hard-coded into the typedef. This limits you to only calling methods of this class or subclasses of it.

With this new type we can store a pointer to any method of the Game class that matches this signature

```c++
// Create a new variable that stores the address of the method.
OnEventFunction eventFunc = &Game::OnEvent;
```

Since this isn't a global function, it can't be called without an instance of an object. For example:

```c++
// Odds are you'll already have an object at hand.
Game game;

// Call the Game's OnEvent method indirectly through a pointer.
(game.*eventFunc)( pEvent );
```

# std::function

This is part of the `<functional>` header.

C++ offers a generic class called std::function that can store a pointer to a global function, a member function and more.

This comes at a cost and can generally be slower than the previous 2 approaches.

Storing and calling the function will look different depending on the function signature.

#### Global Functions

Example of a global function with no parameters that returns an int

```c++
int TestFunc() { return 3; }

std::function<int(void)> functionPtr = TestFunc;

int result = functionPtr();
```

#### Methods

Methods always need an object to be called on, so we use std::bind to bind the function and a specific object together.

Example of a method with no parameters that returns an int:

```c++
int GameObject::TestFunc() { return 3; }

std::function<int(void)> function = std::bind( &GameObject::TestFunc, pGameObject );

int result = function();
```

The binding process is a bit different when the function has parameters:

```c++
void GameObject::TestFunc(int a1, int a2) {}

std::function<void(int, int)> function;

function = std::bind( &GameObject::TestFunc, pGameObject, 
                      std::placeholders::_1, std::placeholders::_2 );

int result = function( 1, 2 );
```

You can always `using namespace std::placeholders;` to make this a bit more compact.
